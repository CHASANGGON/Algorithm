T = int(input())

for test_case in range(1,T+1):
    parenthesis = input()

    stack = []
    laser_check = True
    # 레이저를 발사할 때  '(' 개수만큼 +
    # ')' 는 +1개
    cnt = 0
    for p in parenthesis:
        if p == '(':
            stack.append(p)
            laser_check = True
        elif p == ')' and stack[-1] == '(':
            stack.pop()
            if laser_check == True:
                cnt += len(stack)
            else:
                cnt += 1
            laser_check = False
        elif p == ')' and stack[-1] == ')' and len(stack) >= 1:
            cnt += 1
    print(f'#{test_case} {cnt}')
    #  3 4 4 1 1 3 1
    #  3 7 11 12 13 16

# 스택을 활용하는 문제에요
# 스스로 규칙을 미리 파악하셔야 해요
# 제가 규칙을 발견한 방법은 왼쪽에서 부터 괄호를 체크하면서 값이(생성된 막대 조각의 수) 어떻게 증가하는 지를 보았어요
# 레이저가 한 번 발사될 때 마다, 아래에 있던 쇠막대의 개수만큼 조각이 생성돼요.
# 이 때 레이저가 아직 지나가지 않은 위치의 개수는 확정짓지 않고 진행해요 -> 쇠막대가 해당 위치에서 끝날지 안 끝날지를 모르기 때문에 일단은 레이저의 전 부분까지만 생각해요
# 레이저를 체크하는 방법은, 우선은 입력들이 "(" 이면 스택에 push(append) 해서 저장하고
# 입력으로 ')' 오른쪽 괄호가 주어지면, 스택에 저장된 가장 마지막 값이 '(' 인 경우에 레이저라고 생각하면 돼요
# 레이저가 지나가면 스택에 저장된 '(' 의 개수가 쇠막대의 개수이므로 stack의 길이 만큼 count 해주면 돼요
# 그리고 입력으로 ')' 오른쪽 괄호가 주어졌는데, 스택에 저장된 가장 마지막 값이 ')' 인 경우에는 쇠막대가 끝났다고 생각하면 돼요 그러면 1개의 쇠막대 조각이 발생해요(count)

# 이렇게만 하면 test case 1만 통과해요
# case 2에서는 값이 2개가 추가로 세어져요
# 왜 그런가 저도 디버깅을 하다가 알았는데, 
# (((()(()()) 입력이 여기까지 진행이 됐을 때,
# 중간에 레이저라고 인식해서 pop한 부분을 제외하면 스택에는 (((( 이렇게 남아있는 상태가 돼서
# 이 상황 또한 레이저라고 인식해서 cnt 값이 3이나 증가하게 돼요.
# 원래는 해당 부분에서는 레이저가 발사되고 나서, 쇠막대가 끝나는 상황이니까 cnt 값은 1이 증가가 돼야 해요.

# 그래서 고민끝에, 레이저를 구분하기 위한 변수 laser_check 를 추가해주었습니다.
# 스택에 들어있는 괄호쌍을 비교하지 않고, 바로 이전의 입력을 기억한다면
# 입력이 순차적으로 '(', ')' 가 입력된 것을 체크해서 레이저라는 것을 알 수 있으니까요
# 그리고 또한, 레이저가 발사 된 상황이라고 인식을 해서 그에 맞게 if문으로 처리를 했다면
# 추가적인 오류를 막기 위해 21번 line에서 laser_check 변수를 False로 항상 할당해주어야 해요
# 만약 해당 line의 코드가 왜 필요한지 이해가 되지 않는다면, 해당 line을 지우고 실행시켜보는 것도 좋은 방법이에요.
# 그래도 이해가 되지 않는 다면, 디버깅을 해보면서 값이 순차적으로 어떻게 바뀌는 지 체크해보시구요.
# 정 모르겠다면 언제든 질문하셔도 됩니다
# 열공하세요
    
# 같이 스터디하던 동생이 쓴 방법은 어찌보면 편법일 수도 있긴 한데
# 괄호 문자를 입력받고나서, '()' 괄호쌍을 바로 replace 메서드를 통해서 다른 문자로 바꿔줬다고 하네요
# 그렇게 하면 laser를 잘못 인식하는 일이 발생 안 해서 더 편하게 코드를 짤 수 있긴 한데,
# 문제의 의도와 정확히 일치하는지는 모르겠어용