# 자료를 최소 단위로 나눈 후에 차례대로 정렬하여 최종 결과를 얻어내는 방법
# 분할 과정에서 log n 이 소요
# 정렬 과정에서 n 이 소요
# -> 시간 복잡도 : n longn

# 분할 과정과 정렬 과정이 따로 존재

# 퀵 정렬에서는 같은 값이면 요소의 순서가 바뀔 수 있다 -> 퀵 정렬은 안정성이 보장 안 됨

# 퀵소트는 분할 정복 기법에 의해 동작한다...!
# 중간값(pivot)을 기준으로 왼쪽은 작은 값, 오른 쪽은 큰 값을 만드는 과정을 계속해서 진행
# 최소 단위가 될 때까지 진행하는데
# 병합 정렬은 후처리로 하여금, 요소를 재정렬하는 과정이 추가적으로 진행되지 않음
# (추가 메로리 공간을 사용 X)

def partition(A, l, r):
    # 피봇값을 뽑기
    pivot = A[l]
    # 두 인덱스의 이동 경로 i ---> <--- j 이동 경로
    i, j = l, r
    
    # 이 i, j의 인덱스가 서로 교차 될 때까지 반복 수행...
    while i <= j:
        # i 인덱스는 오른쪽으로 이동...(피봇값보다 큰값이 있다면 중단!)
        while i <= j and A[i] <= pivot:
            i += 1
        # j 인덱스는 왼쪽으로 이동...(피봇값보다 작은값이 있다면 중단!)
        while i <= j and A[j] >= pivot:
            j -= 1
        # i 인덱스와 j 인덱스보다 작을 때에만 교체...!
        # i 인덱스와 j 인덱스가 가리키는 요소를 교환 (swap)
        if i < j:
            A[i], A[j] = A[j], A[i]
    # 피봇과 중간의 값을 교체...!
    # 왜 j값인지, i값과 교환하면 안 되는지 생각해봐
    A[l], A[j] = A[j], A[l]
    return j # 피봇의 위치를 반환

def quick_sort(A, l, r):
    # 기저조건
    if l < r:    
        # 파티셔닝을 진행하고, 피봇값이 있는 s를 가져온다.
        s = partition(A, l, r)
        
        if l > r:
            return 
        
        # 분할기법 : 왼쪽 리스트와 오른쪽 리스트를 다시 정렬 수행
        quick_sort(A, l, s-1)
        quick_sort(A, s+1, r)
        
A = [11, 45, 23, 81, 28, 34]
quick_sort(A, 0, len(A) - 1)
print(A)

A = [11, 45, 22, 81, 23, 34, 99, 22, 17, 8]
quick_sort(A, 0, len(A) - 1)
print(A)

A = [1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
quick_sort(A, 0, len(A) - 1)
print(A)