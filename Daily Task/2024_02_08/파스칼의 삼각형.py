T = int(input())

for test_case in range(1,T+1):
    n = int(input())
    
    dp = [[0]*n for _ in range(n)]
    for i in range(n):
        dp[i][0] = 1
        for j in range(1,i+1): # i행에서는 i개의 값만 존재
            dp[i][j] = dp[i-1][j-1] + dp[i-1][j] # (본인 위치기준) 좌측 상단 + 바로 위의 값의 합 = 본인의 값



    print(f'#{test_case}') # 출력
    for i in range(n):
        for j in range(n):
            if dp[i][j] != 0: # 값이 0이 아닐 때만 출력 
                print(dp[i][j],end =' ')
        print() # 바로 위에서 end=' ' 때문에 줄바꿈이 되지 않기 때문에, 마지막에 print()를 통해서 빈 문자열을 출력해서 줄바꿈 실행
                # 이거 안 하면 틀려요
        

# dp 라는 것이 어떠한 공식이 있는 것이 아니라, 반복되는 불필요한 연산을 줄이기 위한 기법이라고 하니까
# 반복되는 것이 무엇인지를 생각했는데, 그건 그림보면 이미 파악하셨을 거라고 생각해요
# 이 문제에서는 누적합을 통해서 불필요한 연산을 줄이는 정도인 거 같아요.
# 왼쪽 위와 본인 위의 값을 더해서 본인의 값을 만드는 그 규칙은 알겠는데, 그것을 어떻게 시작할지부터가 생각이 안 났습니다.
# 그러다가 리스트를 붙여넣으면서, append를 활용할까 했는데
# 굳이 그렇게 귀찮게 하기 보다는 어차피 리스트는 그냥 미리 선언해버리면 그만이니까
# 값이 0인 n*n개의 2차원 리스트를 미리 선언했습니다. 그리고 그렇게 하니 인덱스로 값에 접근하는 것을 설정하기도 수월했습니다.
# 그 후 제일 왼쪽 값들은 그냥 1로 초기화하고, 나머지는 규칙에 따로 좌측상단과 바로 위의 값을 더해서 값을 할당해주었습니다.
