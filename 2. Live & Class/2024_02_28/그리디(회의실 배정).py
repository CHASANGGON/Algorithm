# 무엇을 기준으로 회의를 선택해야 최대한 많은 횟수의 회의가 될지
# 희망 회의 개수, 시작 시간, 종료 시간을 입력 받는다

# 1. 끝나는 시간을 기준으로 오름차순 정렬한다.
# 2. 빠르게 끝나는 회의를 선택하여 확정한다.
# 3. 이후로 가능한 회의 중, 빠르게 끝나는 회의를 선택하여 확정한다.

# 이상한 제약 조건이 없는 이상, 이런 부류의 문제는 그리디 알고리즘으로 모두 풀린다!
# 첫 번째로 종료 시간 또는 지점을 1차 기준으로 오름차순 정렬한다는 것을 기억하고
# 두 번째로는 그렇게 정렬된 것들 중에서 가능하다면 제일 빠른 것들을 하나씩 확정 지으면 된다.

# 10
# 1 10
# 3 5
# 6 10
# 15 19
# 2 3
# 23 25
# 20 23
# 6 9
# 5 8
# 12 15



n = int(input())

arr = [list(map(int,input().split())) for _ in range(n)]

arr.sort(key = lambda x : (x[1], x[0]))

lst = [arr[0]]
cnt = 1
for a in arr:
    if lst[-1][1] <= a[0]:
        lst.append(a)
        cnt += 1

print(f'{cnt}개의 회의 가능')
print(*lst)
